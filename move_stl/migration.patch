--- ./sources/linked_table.move
+++ ./sources/linked_table.move
@@ -10 +10 @@
-    struct LinkedTable<K: store + drop + copy, phantom V: store> has key, store {
+    public struct LinkedTable<K: store + drop + copy, phantom V: store> has key, store {
@@ -17 +17 @@
-    struct Node<K: store + drop + copy, V: store> has store {
+    public struct Node<K: store + drop + copy, V: store> has store {
@@ -201 +201 @@
-        let table = new<u64, u256>(ctx);
+        let mut table = new<u64, u256>(ctx);
@@ -238 +238 @@
-        let table = new<u64, u256>(ctx);
+        let mut table = new<u64, u256>(ctx);
@@ -275 +275 @@
-        let table = new<u64, u256>(ctx);
+        let mut table = new<u64, u256>(ctx);
@@ -330 +330 @@
-        let table = new<u64, u256>(ctx);
+        let mut table = new<u64, u256>(ctx);
@@ -383 +383 @@
-        let table = new<u64, u256>(ctx);
+        let mut table = new<u64, u256>(ctx);
@@ -439,2 +439,2 @@
-        let table = new<u64, u256>(ctx);
-        let n = 0;
+        let mut table = new<u64, u256>(ctx);
+        let mut n = 0;
@@ -452,2 +452,2 @@
-        let table = new<u64, u256>(ctx);
-        let n = 0;
+        let mut table = new<u64, u256>(ctx);
+        let mut n = 0;
@@ -465,3 +465,3 @@
-        let table = new<u64, u64>(ctx);
-        let n = 10000;
-        let current_key = 20000;
+        let mut table = new<u64, u64>(ctx);
+        let mut n = 10000;
+        let mut current_key = 20000;
@@ -482,3 +482,3 @@
-        let table = new<u64, u64>(ctx);
-        let n = 1;
-        let current_key = 0;
+        let mut table = new<u64, u64>(ctx);
+        let mut n = 1;
+        let mut current_key = 0;
--- ./sources/option_u128.move
+++ ./sources/option_u128.move
@@ -7 +7 @@
-    struct OptionU128 has copy, drop, store {
+    public struct OptionU128 has copy, drop, store {
@@ -67 +67 @@
-        let n = 0;
+        let mut n = 0;
@@ -77 +77 @@
-        let n = 0;
+        let mut n = 0;
--- ./sources/option_u64.move
+++ ./sources/option_u64.move
@@ -7 +7 @@
-    struct OptionU64 has copy, drop, store {
+    public struct OptionU64 has copy, drop, store {
@@ -60 +60 @@
-        let n = 0;
+        let mut n = 0;
@@ -70 +70 @@
-        let n = 0;
+        let mut n = 0;
--- ./sources/random.move
+++ ./sources/random.move
@@ -3 +3 @@
-    struct Random has drop, store, copy {
+    public struct Random has drop, store, copy {
@@ -35,2 +35,2 @@
-        let random = new(0);
-        let n = 0;
+        let mut random = new(0);
+        let mut n = 0;
@@ -45,2 +45,2 @@
-        let random = new(0);
-        let n = 0;
+        let mut random = new(0);
+        let mut n = 0;
@@ -55,2 +55,2 @@
-        let random = new(0);
-        let n = 0;
+        let mut random = new(0);
+        let mut n = 0;
--- ./sources/skip_list.move
+++ ./sources/skip_list.move
@@ -17 +17 @@
-    struct SkipList<phantom V: store> has key, store {
+    public struct SkipList<phantom V: store> has key, store {
@@ -39 +39 @@
-    struct Node<V: store> has store {
+    public struct Node<V: store> has store {
@@ -169,3 +169,3 @@
-        let (level, new_node) = create_node(list, score, v);
-        let (l, nexts, prev) = (list.level, &mut list.head, none());
-        let opt_l0_next_score = none();
+        let (level, mut new_node) = create_node(list, score, v);
+        let (mut l, mut nexts, mut prev) = (list.level, &mut list.head, none());
+        let mut opt_l0_next_score = none();
@@ -173 +173 @@
-            let opt_next_score = vector::borrow_mut(nexts, l - 1);
+            let mut opt_next_score = vector::borrow_mut(nexts, l - 1);
@@ -208 +208 @@
-        let (l, nexts) = (list.level, &mut list.head);
+        let (mut l, mut nexts) = (list.level, &mut list.head);
@@ -211 +211 @@
-            let opt_next_score = vector::borrow_mut(nexts, l - 1);
+            let mut opt_next_score = vector::borrow_mut(nexts, l - 1);
@@ -272 +272 @@
-        let (l, nexts,current_score) = (list.level, &list.head, none());
+        let (mut l, mut nexts,mut current_score) = (list.level, &list.head, none());
@@ -274 +274 @@
-            let opt_next_score = *vector::borrow(nexts, l - 1);
+            let mut opt_next_score = *vector::borrow(nexts, l - 1);
@@ -295,2 +295,2 @@
-        let level = 1;
-        let mod = list.list_p;
+        let mut level = 1;
+        let mut mod = list.list_p;
@@ -361 +361 @@
-        let next_score = vector::borrow(&list.head, 0);
+        let mut next_score = vector::borrow(&list.head, 0);
@@ -379,5 +379,5 @@
-            size,
-            opt_next_score,
-            tail,
-            prev,
-            current_score,
+            mut size,
+            mut opt_next_score,
+            mut tail,
+            mut prev,
+            mut current_score,
@@ -418 +418 @@
-        let l = list.level - 1;
+        let mut l = list.level - 1;
@@ -420,2 +420,2 @@
-            let opt_next_l_score = vector::borrow(&list.head, l);
-            let opt_next_0_score = vector::borrow(&list.head, 0);
+            let mut opt_next_l_score = vector::borrow(&list.head, l);
+            let mut opt_next_0_score = vector::borrow(&list.head, 0);
@@ -442 +442 @@
-        let (opt_next_score,scores ) = (vector::borrow(&list.head, 0), vector::empty<u64>());
+        let (mut opt_next_score,mut scores ) = (vector::borrow(&list.head, 0), vector::empty<u64>());
@@ -465,2 +465,2 @@
-        let skip_list = new<u256>(16, 2, 12345, ctx);
-        let n = 0;
+        let mut skip_list = new<u256>(16, 2, 12345, ctx);
+        let mut n = 0;
@@ -479,2 +479,2 @@
-        let random = random::new(seed);
-        let n = 0;
+        let mut random = random::new(seed);
+        let mut n = 0;
@@ -496 +496 @@
-        let list = new<V>(max_leveL, list_p, seed, ctx);
+        let mut list = new<V>(max_leveL, list_p, seed, ctx);
@@ -513,2 +513,2 @@
-        let list = new<u256>(16, 2, 100000, ctx);
-        let n = 0;
+        let mut list = new<u256>(16, 2, 100000, ctx);
+        let mut n = 0;
@@ -526 +526 @@
-    struct Item has drop, store {
+    public struct Item has drop, store {
@@ -540 +540 @@
-        let n = length;
+        let mut n = length;
@@ -585,2 +585,2 @@
-        let random = random::new(12345);
-        let n = 0;
+        let mut random = random::new(12345);
+        let mut n = 0;
@@ -588 +588 @@
-            let score = random::rand_n(&mut random, 1000000);
+            let mut score = random::rand_n(&mut random, 1000000);
@@ -604,2 +604,2 @@
-        let n = 0;
-        let finded = find_next(&list, 99999, true);
+        let mut n = 0;
+        let mut finded = find_next(&list, 99999, true);
@@ -618 +618 @@
-        let list = new_list_for_test<u256>(16, 2, 1000, 5678, 0, ctx);
+        let mut list = new_list_for_test<u256>(16, 2, 1000, 5678, 0, ctx);
@@ -620 +620 @@
-        let (n, length) = (0, vector::length(&scores));
+        let (mut n, length) = (0, vector::length(&scores));
@@ -637,2 +637,2 @@
-        let (n, length) = (0, vector::length(&scores));
-        let skip = 0;
+        let (mut n, length) = (0, vector::length(&scores));
+        let mut skip = 0;
--- ./sources/skip_list_u128.move
+++ ./sources/skip_list_u128.move
@@ -14 +14 @@
-    struct SkipList<V: store> has key, store{
+    public struct SkipList<V: store> has key, store{
@@ -36 +36 @@
-    struct SkipListNode<V: store> has store {
+    public struct SkipListNode<V: store> has store {
@@ -169,3 +169,3 @@
-        let (level, new_node) = create_node(list, score, v);
-        let (l, nexts, prev) = (list.level, &mut list.head, none());
-        let opt_l0_next_score = none();
+        let (level, mut new_node) = create_node(list, score, v);
+        let (mut l, mut nexts, mut prev) = (list.level, &mut list.head, none());
+        let mut opt_l0_next_score = none();
@@ -173 +173 @@
-            let opt_next_score = vector::borrow_mut(nexts, l - 1);
+            let mut opt_next_score = vector::borrow_mut(nexts, l - 1);
@@ -205 +205 @@
-        let (l, nexts) = (list.level, &mut list.head);
+        let (mut l, mut nexts) = (list.level, &mut list.head);
@@ -208 +208 @@
-            let opt_next_score = vector::borrow_mut(nexts, l - 1);
+            let mut opt_next_score = vector::borrow_mut(nexts, l - 1);
@@ -265 +265 @@
-        let (l, nexts,current_score) = (list.level, &list.head, none());
+        let (mut l, mut nexts,mut current_score) = (list.level, &list.head, none());
@@ -267 +267 @@
-            let opt_next_score = *vector::borrow(nexts, l - 1);
+            let mut opt_next_score = *vector::borrow(nexts, l - 1);
@@ -288,2 +288,2 @@
-        let level = 1;
-        let mod = list.list_p;
+        let mut level = 1;
+        let mut mod = list.list_p;
@@ -354 +354 @@
-        let next_score = vector::borrow(&list.head, 0);
+        let mut next_score = vector::borrow(&list.head, 0);
@@ -372,5 +372,5 @@
-            size,
-            opt_next_score,
-            tail,
-            prev,
-            current_score,
+            mut size,
+            mut opt_next_score,
+            mut tail,
+            mut prev,
+            mut current_score,
@@ -411 +411 @@
-        let l = list.level - 1;
+        let mut l = list.level - 1;
@@ -413,2 +413,2 @@
-            let opt_next_l_score = vector::borrow(&list.head, l);
-            let opt_next_0_score = vector::borrow(&list.head, 0);
+            let mut opt_next_l_score = vector::borrow(&list.head, l);
+            let mut opt_next_0_score = vector::borrow(&list.head, 0);
@@ -435 +435 @@
-        let (opt_next_score,scores ) = (vector::borrow(&list.head, 0), vector::empty<u128>());
+        let (mut opt_next_score,mut scores ) = (vector::borrow(&list.head, 0), vector::empty<u128>());
@@ -458,2 +458,2 @@
-        let skip_list = new<u256>(16, 2, 12345, ctx);
-        let n = 0;
+        let mut skip_list = new<u256>(16, 2, 12345, ctx);
+        let mut n = 0;
@@ -471,2 +471,2 @@
-        let random = random::new(seed);
-        let n = 0;
+        let mut random = random::new(seed);
+        let mut n = 0;
@@ -488 +488 @@
-        let list = new<V>(max_leveL, list_p, seed, ctx);
+        let mut list = new<V>(max_leveL, list_p, seed, ctx);
@@ -505,2 +505,2 @@
-        let list = new<u256>(16, 2, 12345, ctx);
-        let n = 0;
+        let mut list = new<u256>(16, 2, 12345, ctx);
+        let mut n = 0;
@@ -518 +518 @@
-    struct Item has drop, store {
+    public struct Item has drop, store {
@@ -532 +532 @@
-        let n = length;
+        let mut n = length;
@@ -577,2 +577,2 @@
-        let random = random::new(12345);
-        let n = 0;
+        let mut random = random::new(12345);
+        let mut n = 0;
@@ -580 +580 @@
-            let score = (random::rand_n(&mut random, 1000000) as u128);
+            let mut score = (random::rand_n(&mut random, 1000000) as u128);
@@ -596,2 +596,2 @@
-        let n = 0;
-        let finded = find_next(&list, 99999, true);
+        let mut n = 0;
+        let mut finded = find_next(&list, 99999, true);
@@ -610 +610 @@
-        let list = new_list_for_test<u256>(16, 2, 1000, 5678, 0, ctx);
+        let mut list = new_list_for_test<u256>(16, 2, 1000, 5678, 0, ctx);
@@ -612 +612 @@
-        let (n, length) = (0, vector::length(&scores));
+        let (mut n, length) = (0, vector::length(&scores));
@@ -629,2 +629,2 @@
-        let (n, length) = (0, vector::length(&scores));
-        let skip = 0;
+        let (mut n, length) = (0, vector::length(&scores));
+        let mut skip = 0;
